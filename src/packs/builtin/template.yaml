# =====================================================================
#  Generic Game Pack Template
#  Purpose: teach authors how packs work and what each field means.
#  This file is data only. Your engine parses, validates, and executes it.
#  Conventions:
#    - All ids are lowercase snake_case and stable.
#    - Labels are display strings that UIs can render and translate.
#    - Formulas are written in a small expression language your engine supports.
#    - Everything here is optional until you enable it in 'schema' or 'mechanics'.
# =====================================================================

metadata:
  # A unique stable id for the game system. This becomes the namespace for content.
  id: example_system
  # Human readable name for UI display.
  name: "Example System"
  # Semantic version of the pack content. Use x.y.z and bump on incompatible changes.
  version: "1.0.0"
  # Attribution for authorship and license information.
  author: "Your Name"
  license: "CC BY 4.0"
  homepage: ""

# ---------------------------------------------------------------------
# SCHEMA
# Describes what exists: stats, resources, inventory slots, tags, and
# named derived values the engine can compute and expose to panels.
# The engine will initialize characters and UIs from this schema.
# ---------------------------------------------------------------------
schema:
  # Core scalar attributes. Each is a named numeric value.
  # Add as many as your system needs. The engine does not assume specific ones.
  attributes:
    - id: strength
      label: Strength
      description: "General physical power."
      min: 0                  # optional numeric lower bound
      max: 999                # optional numeric upper bound
      default: 0              # starting value for new characters
    - id: agility
      label: Agility
      description: "Speed and finesse."
      min: 0
      max: 999
      default: 0

  # Pooled resources with a current and a maximum. Examples: HP, Mana, Stamina.
  # defaultMaxFormula is evaluated by the engine to create initial max values.
  resources:
    - id: health
      label: Health
      description: "General vitality or hit points."
      defaultMaxFormula: "100"         # constant or expression, e.g., "50 + strength * 5"
    - id: mana
      label: Mana
      description: "Pool for abilities or spells."
      defaultMaxFormula: "0"           # set to 0 if unused by a pack

  # Optional proficiency or mastery categories with discrete ranks.
  # Ranks are ordered left to right from weakest to strongest.
  proficiencyCategories:
    - id: weapon_skill
      label: Weapon Skill
      ranks: [untrained, trained, expert, master, legendary]

  # Equipment slot taxonomy. Controls what can be equipped and how many at once.
  itemSlots:
    - id: head
      label: Head
      maxEquipped: 1
    - id: ring
      label: Ring
      maxEquipped: 2
    - id: main_hand
      label: Main Hand
      maxEquipped: 1
    - id: off_hand
      label: Off Hand
      maxEquipped: 1
    - id: armor
      label: Armor
      maxEquipped: 1

  # Global tags you want rules to query for filtering effects and actions.
  tags: [melee, ranged, spell, fire, cold, physical, magical]

  # Named computed values that UIs may display and other rules may reference.
  # The formula is an expression in your small language. Use accessors like attr.*, res.*, prof.*, and derived.*.
  derived:
    - id: attack_power
      label: Attack Power
      formula: "strength * 2"
    - id: defense_rating
      label: Defense Rating
      formula: "10 + floor(agility / 2)"

# ---------------------------------------------------------------------
# MECHANICS
# High level toggles for health models, inventory capacity, dice behavior,
# progression, spellcasting resources, rest and regeneration, and currency.
# UIs and rules should branch on these settings rather than hardcoding.
# ---------------------------------------------------------------------
mechanics:
  # Health model
  #   model = "resource" uses a numeric pool resource referenced by resourceId
  #   model = "hits" uses a small integer count of hits the character can take
  #   model = "both" allows a hybrid model if your system requires it
  health:
    model: "resource"
    resourceId: "health"

  # Inventory capacity model
  #   mode = "slot_limit" caps the number of inventory slots
  #   mode = "weight_limit" caps carry weight using weightLimitFormula
  #   mode = "hybrid" uses both at once
  inventory:
    mode: "weight_limit"
    maxSlots: 36
    weightLimitFormula: "strength * 15"

  # Dice and randomness rules. The engine supplies the functions referenced here.
  dice:
    advantageRule: "max(roll(d20), roll(d20))"    # example for 2d20 keep highest
    disadvantageRule: "min(roll(d20), roll(d20))"
    criticalHit:
      threshold: 20
      damageRule: "double_dice"                 # alternative could be "max_dice" or a custom formula

  # Progression modes. Turn on any combination that applies to your system.
  progression:
    modes:
      characterLevel: true
      classLevel: false
      skillLevel: false
    xp:
      track: "character"                        # "character", "class", or "none"
      expToLevel: "round(pow(level, 2) * 100)"  # experience curve as a formula
    proficiency:
      formula: "lookup('proficiency_by_level', level)"

  # Spellcasting or power resource model.
  # style can be "slots", "mana", "both", or "none".
  spellcasting:
    style: "none"
    slots:
      table: "spell_slots_by_level"             # optional lookup table for slot counts
    mana:
      resourceId: "mana"
      spendRule: "cost = powerRank * 2"
      regenFormula: "0"

  # Rest and regeneration. UIs can trigger shortRest or longRest as actions.
  rest:
    shortRest:
      healthRegen: "0"                          # e.g., "roll(d6) + floor(level / 2)"
      manaRegen: "0"
    longRest:
      healthRegen: "res.health.max"
      manaRegen: "res.mana.max"
    overtime:
      tickSeconds: 0                            # 0 disables background ticks
      healthPerTick: "0"
      manaPerTick: "0"

  # Currency and economy. If hasCurrency is false, UIs can hide money views.
  economy:
    hasCurrency: false
    baseUnit: "credit"
    currencies:
      - { id: credit, label: Credit, ratioToBase: 1 }

# ---------------------------------------------------------------------
# RULES
# Global operator set, stacking policies, reusable formulas and lookups,
# and event triggers. Packs define behavior with data. The engine executes it.
# ---------------------------------------------------------------------
rules:
  # The engine supports these operators in expressions. Validation can check usage.
  operators: [add, sub, mul, div, min, max, floor, ceil, round, clamp, if, and, or, not]
  # How multiple modifiers combine when they target the same value.
  stackingPolicies:
    - additive                 # sum all amounts
    - highest_only             # choose highest amount
    - typed_bonus_non_stack    # within same type take highest, different types add
    - multiply_after_add       # apply multipliers after additive subtotal
  # Named formulas your pack or items may reference by name.
  # Values here are declarations for authors. The engine supplies implementations.
  formulas:
    mod: "declare:number -> number"
    roll: "declare:dice -> number"
    take_higher_of: "declare:number,number -> number"
    take_lower_of: "declare:number,number -> number"
    # You can declare helpers like armor_cap(), shield_bonus(), or stamina_cost() as needed.

  # Small lookup tables that expressions can query with lookup('table', key).
  lookups:
    proficiency_by_level:
      "1": 1
      "5": 2
      "9": 3
      "13": 4
      "17": 5
    spell_slots_by_level:
      "1": { "1": 2 }       # level 1 gets two rank 1 slots
      "2": { "1": 3 }       # sample only; packs can fill real data

  # Event driven rules you want to activate. The engine raises events and evaluates attached effects.
  # Examples: on_equip, on_unequip, on_action("attack"), on_hit, on_turn_start, on_rest("short")
  triggers: []

  # Optional hints for the dependency graph. Helps the engine know what derived nodes depend on.
  dependencyHints: []

# ---------------------------------------------------------------------
# CONTENT
# Concrete data entities players use: items, traits, actions, conditions,
# and extra lookups. Effects attach modifiers that reference targets with policies and scopes.
# ---------------------------------------------------------------------
content:
  # Items can equip into slots and attach effects. Effects use a standard modifier shape.
  items:
  # - id: leather_armor
  #   label: Leather Armor
  #   slot: armor
  #   weight: 10
  #   tags: [armor, light]
  #   effects:
  #       - target: "derived.defense_rating"     # what to change
  #         operation: "add"                     # how to change it
  #         amount: 1                            # number or formula name
  #         policy: "typed_bonus_non_stack"      # how to stack with other bonuses
  #         type: "armor"                        # used by typed stacking policies
  #         timing: "always"                     # when it applies
  #         scope: {}                            # filters, e.g., only melee
  #         priority: 0                          # tie breaker for conflicts

  # Traits are passive characteristics that can also grant effects.
  traits: []

  # Actions are things a character can do. Availability is an expression. Effects apply on success or use.
  actions:
  # - id: basic_attack
  #   label: Basic Attack
  #   category: "attack"
  #   tags: [melee]
  #   availability: "true"
  #   costs:
  #       resourceId: "stamina"
  #       amount: 1
  #   effects:
  #       - target: "outcome.damage[physical]"
  #         operation: "add"
  #         amount: "roll(d6) + strength"
  #         policy: "additive"
  #         timing: "on_action('basic_attack')"

  # Conditions are temporary states like poisoned or inspired. They attach effects while active.
  conditions: []

  # Extra lookup tables specific to this pack. The engine exposes them to lookup().
  lookups: {}

# ---------------------------------------------------------------------
# UI PRESET
# Default GoldenLayout workspace and per panel options. Your app should
# persist per character layouts, but use this preset for first time setup.
# Panels are referenced by stable registry keys like "panel.attributes".
# ---------------------------------------------------------------------
uiPreset:
  layout:
    # An empty layout is valid. Packs can define a starter layout like two stacks and a floating dice panel.
    content: []
  panelOptions:
    attributes:
      # Authors can influence ordering or visibility without code changes.
      order: [strength, agility]
    inventory:
      showWeight: true
      showSlots: true
  theme:
    # Optional color token overrides so different packs can brand their UI.
    # primary: "#4f46e5"
    # surface: "#0b0b12"
    # text: "#eaeaf3"
    {}
